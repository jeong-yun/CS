운영체제(OS) : 프로그램들을 실행하는 메인 프로그램. 하드웨어 자원 이용. 
컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어
네트워크 통신, 입출력 장치 관리 등 모든 것 관리
운영체제 목적: 1) 신뢰도 향상	2) 응답시간 단축	 	3) 반환시간 감소		4) 처리량 증가

-커널(Kernel): 모든 운영체제를 메모리에 올리면 낭비 -> 필요 부분(커널)만 올린 후 그 외의 부분은 필요시 올림. 즉 메모리(주기억장치)에 상주하는 운영체제
	하드웨어의 자원을 이용해 프로그램을 관리하는 역할.
	역할: 하드웨어 보호. 프로세스 관리. 기억장치 관리. 입출력 장치 관리

셸(Shell): 커널과 사용자 사이에서 명령어 해석기 역할.(보조기억 장치에 상주)

유틸리티: 일반 사용자가 응용프로그램을 처리하는데 사용

1단계 디렉터리 구조: 가장 간단. 모든 파일이 하나의 디렉터리 내에 위치하여 관리.
2단계 디렉터리 구조: 중앙에 마스터 파일 디렉터리가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉터리 구조
트리 디렉터리 구조: 하나의 루트 디렉터리와 여러 개의 종속 디렉터리로 구성
일반 그래프 디렉터리 구조: 트리 구조에서 링크를 첨가시켜 순환을 허용하는 그래프 구조
비순환 그래프 디렉터리 구조: 하위 파일이나 하위 디렉터리를 공동으로 사용할 수 있는 것으로 사이클이 허용되지 않는 구조

운영체제 관리 단위
	-프로세스 관리: 프로세스를 생성, 실행을 제어, 관리
	-메인 메모리 관리: 프로세스가 실행될 수 있도록 메인 메모리 공간 할당 및 회수
	-파일 관리: 파일을 보조기억 장치에 저장하고 파일 시스템을 운영
	-입출력 관리
	-보조기억 장치 관리: 보조기억 장치의 공간을 할당 및 관리
	-네트워킹: 통신에 필요한 자원들 제어 및 관리
	-정보보안: 사용자 인증 및 실행 권한 관리
	-명령 해석 시스템: 사용자 명령어를 해석하고 관련 함수를 실행

운영체제 운용 기법: 운영체제마다 시스템을 관리하는 방식이 다름
	1)일괄 처리 시스템: 초기 컴퓨터(1950 1세대) 시스템에서 사용된 운영체제 관리 스타일. 일정 데이터 모아 한 번에 처리
	2)다중 프로그래밍 시스템: 1960년대 2세대 관리 스타일. 하나의 cpu와 주기억 장치 이용 -> 여러 개의 프로그램을 동시에 처리
	3)실시간 처리 시스템: 1960년대 2세대 관리 스타일. 교통제어, 은행 업무 등 빠른 처리가 필요한 작업에 주로 사용
	4)다중 처리 시스템: 1960년대 2세대 관리 스타일. 여러 개의 cpu와 하나의 주기억 장치 이용-> 여러 개의 프로그램 동시에 처리. 속도 빠름 -> 입출력 장치 공유로 스케줄링 필요
	5)시분할 시스템: 1960년 3세대 관리 스타일, 여러 명의 사용자가 사용하는 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리 -> 각 사용자들에게 독립된 컴퓨터를 사용하는 느낌을 주는 방식 다중 프로그래밍 시스템 보다 많은 작업량 실행 가능
	6)다중 모드 시스템: 1970년 4세대 관리 스타일. 일괄 처리 & 시분할 & 다중처리 & 실시간 처리 시스템 모두 제공
	7)분산처리 시스템: 1970년 5세대 및 현대 스타일. 여러 개의 컴퓨터(프로세서)를 통해 통신 회선을 연결하여 하나의 작업을 처리하는 방식. 

분산처리 시스템 목적: 자원 공유.	연산속도 향상. 신뢰도 향상. 컴퓨터 통신
분산처리 시스템 장점: 통신 용이. 장치 공유. 데이터 공유. 중앙컴퓨터 과부하 줄임. 위치x -> 자원 사용 가능. 점진적 확장 가능
분산처리 시스템 단점: 소프트웨어 개발이 어려움. 보안문제 발생. 설계 복잡

-CPU: 시스템을 통제하고 프로그램이 돌아가는 모든 계산을 진행
	-제어장치: 컴퓨터 시스템의 작동을 통제 및 지시하는 장치
	-연산장치: 연산 부분 담당
	-레지스터: 임시 기억 장소 역할
*레지스트리: 윈도우 시스템이 운영되는데 필요한 정보를 가지고 있음

-메모리(기억 장치): 전기적인 신호를 내부에서 임시적으로 저장하는 역할
	1)내부 메모리: cpu의 계산 결과 저장, 프로그램이 실행되는 공간을 제공
	2)외부 메모리: 디스크, 외장하드 같은 보조 기억 장치
		*디스크: 정보를 영구적으로 저장하는 역할

가상 메모리: 가상 메모리는 램 공간이 부족할때 윈도우에서 사용하는 파일. 가상메모리를 사용한다는 것은 페이징 파일과 정보를 이동하여 충분한 램을 확보하여 높은 메모리를 요구하는 프로그램이 올바르게 실행되도록 하는 것.

-입출력 장치: 데이터를 입력하고 출력하는 데 필요한 장치

-시스템 버스: 컴퓨터의 구성요소를 서로 연결하고 데이터를 전달하기 위한 경로
	제어 버스: 제어 신호 전달
	주소 버스: 메모리의 주소나 입출력 장치의 포트 번호 전달
	데이터 버스: 데이터 전달

프로세스: 실행중인 프로그램. 즉, 프로그램 실행 = 프로세스 생성. 메모리에 적재 된 프로그램. 운영체제로부터 자원을 할당받아 실행.
	구성: 프로그램 정보, 실행시 사용되는 데이터
스레드: 프로세스 내에서 실행되는 흐름의 단위. 프로세스로부터 자원을 할당받아 실행
멀티프로세스: 각 프로세스는 독립적으로 실행되며, 각각 별개의 메모리를 차지 
멀티스레드: 프로세스 내의 메모리를 공유, 프로세스간 전환보다 스레드간의 전환 속도 빠름
	장점: CPU가 여러 개일 경우 각각의 CPU가 스레드를 하나씩 담당 -> 속도 증가 -> 동시에 수행
	단점: 각각의 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없음.

실행할 프로그램(코드 영역) -> 전역변수, 정적변수, 상수 저장(데이터 영역) -> 사용자의 동적 할당(힙 영역) -> 지역변수, 매개변수(스택 영역)
-힙 영역: 개발자가 직접 관리하는 영역
	동적 할당: 실행 중에 사용할 메모리 공간을 특정 크기까지 할당하는 것
	정적 할당: 
-스택 영역: 함수 호출과 관계되는 지역변수, 매개변수 저장 영역. 함수 호출 완료 후 사라지는 영역. 프로그램이 자동으로 사용하는 임시 메모리
	   즉 정적 할당 영역

Distributed Computing(분산처리기술): 여러대의 컴퓨터 계산 및 저장능력을 이용하여 커다란 계산문제/대용량 데이터처리/저장 하는 기술

시분할 처리 시스템(Time-Sharing System): 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아 가며 처리
실시간 처리 시스템(Real-Time System): 데이터 발생 즉시, 또는 데이터 처리 요구가 있는 즉시 처리하여 결과를 산출
다중 프로그래밍 시스템(Multi-Programming System): 하나의 CPU와 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식
다중 처리 시스템(Multi-Processing System): 동시에 프로그램을 수행할 수 있는 CPU를 두 개 이상 두고 각각 그 업무를 분담하여 처리하는 방식

Race Condition: 두 개의 스레드가 하나의 자원을 놓고 서로 경쟁하는 상황
Critical Section(임계구역, 공유변수 영역): 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부. 
임계 구역은 지정된 시간이 지난 후 종료. 때문에 어떤 스레드(프로세스)가 임계 구역에 들어가고자 한다면 지정된 시간만큼 대기해야 함. 
스레드가 공유자원의 배타적인 사용을 보장받기 위해서 임계 구역에 들어가거나 나올 때는 세마포어 같은 동기화 매커니즘이 사용.

예방 방법 1) Semaphore: 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근하는 것을 막음(즉, 동기화 대상이 하나 이상)
		운영체제 또는 커널의 한 지정된 저장장치 내 값으로서, 각 프로세스는 이를 확인하고 변경할 수 있음. 
		세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야함.
	  2) Mutual exclusion(상호 배제, Mutex): Race condition을 막기 위해서 두 개 이상의 프로세스가 공용 데이터에 동시에 접근을 하는 것을 막는 것. 
		즉 한 프로세스가 공용 데이터를 사용하고 있으면 그 자원을 사용하지 못하도록 막는 것. 
		공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 하나의 Process 혹은 Thread가 접근하는 것을 막음(즉, 동기화 대상이 하나). 
		Critical Section을 가진 쓰레드들의 Runnig Time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술. 
		다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking과 unlocking을 사용. 
		뮤텍스 객체를 두 쓰레드가 동시에 사용할 수 없다는 의미입니다.
	-Deadlock(교착상태): 상호 배제 시 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태. 
		작업을 해야 하는 프로세스가 접근할 수 없는 특정자원을 Asleep 상태에서 무한히 기다리는 상태. (자원 부족의 문제)
	-Starvation(기아 상태): 상호 배제 시 프로세스들이 더 이상 진행을 하지 못하고 영구적으로 블록되어 있는 상태. (자원 할당 시 소외될 때 발생하는 문제)
	 	작업을 해야 하는 프로세스가 어떠한 우연 또는 문제로 인해서 프로세서(CPU)를 할당받지 못해 Ready 상태에서 더 이상 진행하지 못하는 상태

Banker’s algorithm: Dead Lock을 회피하는 알고리즘. 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는 지를 사전에 검사.

mutex vs semaphore
1) Semaphore는 Mutex가 될 수 있지만 Mutex는 Semaphore가 될 수 없음.
2) Semaphore는 소유할 수 없는 반면, Mutex는 소유가 가능하며 소유주가 이에 대한 책임을 짐.(Mutex 의 경우 lock 을 ‘가질’ 수 있음)
3) Mutex의 경우 Mutex를 소유하고 있는 스레드가 Mutex를 해제. Semaphore의 경우 Semaphore를 소유하지 않는 쓰레드가 Semaphore를 해제
4) Semaphore는 시스템 범위에 걸쳐있고 파일시스템상의 파일 형태로 존재. 반면 Mutex는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up.

임계구역 문제 해결 3가지 조건 충족
1. 상호 배제 (mutual exclusion): 하나의 프로세스가 임계 구역에서 실행되고 있다면, 다른 프로세스들은 임계 구역에서 실행될 수 없음.
2. 진행 (progress): 임계 구역에 실행되고 있는 프로세스가 없을 경우, 들어갈 프로세스를 적절히 선택해 줘야 함.
3. 한정된 대기 (bounded waiting): 프로세스의 기아를 방지하기 위해, 한번 임계 구역에서 실행된 프로세스는 다음 실행에 대한 제한을 두어야함.

파일 보호  기법
Naming: 접근하고자 하는 파일 이름을 모르는 사용자를 접근 대상에서 제외
Password: 암호를 아는 사용자에게만 접근을 허용
Access Control: 사용자의 신원에 ᄄᆞ라 서로 다른 접근 권한을 허용

기억장치 구현
1. Segmentation 기법: 기억장치 보호키 필요, Segment map table 필요, 프로그램을 여러 블록으로 나누어 수행, 고유 이름 및 크기 존재

SSTF 스케줄링: 1. 숫자 크기순으로 정렬 	2. 짧은 거리 계산
FCFS 스케줄링: 요청이 들어온 순서대로 처리
SSTF 스케줄링: 현재 디스크 헤드 위치에서 가장 가까운 실린더에 대한 요청을 우선적으로 처리
SCAN 스케줄링: 디스크의 한 쪽 끝에서 반대쪽 끝으로 이동하면서 처리. 마지막 실린더에 도착하면 반대 방향으로 스캔 진행
C-SCAN 스케줄링: 디스크의 한쪽 끝에서 반대쪽 끝으로 이동하면서 처리. 마지막 실런더에 도착하면 시작점으로 되돌아간 후 다시 스캔
C-Look 스케줄링: C-SCAN과 유사. 요청된 실린더 중 마직막까지만 이동하는 방식으로 처리
SJF(Shortest Job First) 스케줄링: FCFS 해결 위해 개발.
STR(Shortest Remaining Time) 스케줄링: 비선점 스케줄링인 SJF기법을 선점 형태로 변경한 기법.

가상화: 물리적인 리소스들을 사용자에게 하나로 보이게 하거나, 반대로 하나의 물리적인 리소스를 여러 개로 보이게 하는 것

페이지 교체 기법: 페이징 기법으로 메모리를 관리하는 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시(페이지 부재) 어떤 페이지 프레임을 선택하여 교체할 것인지 결정하는 방법을 페이지 교체 알고리즘
LRU(Least Recent Used): 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
NUR(Not Used Recently): 최근에 사용하지 않은 페이지를 교체. 참조 비트와 변형 비트 사용.
MFU(Most Frequently Used): 참조 횟수가 가장 많은 페이지 교체.
LFU(Least Frequently Used): 참조 횟수가 가장 적은 페이지 교체.

RR(Round-Robin) 스케줄링: 시분할을 위해 고안된 선점형 스케줄링. 시간 할당이 커지면 FCFS와 같고, 시간할당이 작아지면 문맥교환이 자주 일어남
HRN(Hightest Response-ratio Next) 스케줄링: (대기시간 + 서비스시간)/서비스시간
MFQ(Multilevel Feedback Queue) 스케줄링: 모든 작업이 큐에서 실행되며 각 큐에선 할당시간 존재

UNIX 명령어
cp: 파일 복사	cat: 파일 내용 화면 표시		ls: 현재 디렉터리 내의 파일 목록 확인	chmod: 파일의 사용 허가 지정

부트 블록: 부팅 시 필요한 코드를 저장하고 있는 블록
슈퍼 블록: 전체 파일 시스템에 대한 정보를 저장하고 있는 블록(가능한 I-Node, 디스크 블록의 개수를 알수 있음)
데이터 블록: 디렉터리별로 디렉터리 엔트리와 실제 파일에 대한 데이터가 저장된 블록

주/종시스템
주: 입출력과 연산을 담당
종: 연산만 담당
주 프로세스 고장 시 시스템 다운

인터프리터(Interpreter): 프로그램 문장을 하나씩 번역하고 실행할 수 있도록 하는 프로그램

Buffer Overflow: 루트권한과 관련된 프로그램에 예상치 못한 입력값을 보내 해당 프로그램에 에러를 유발하는 것. 정해진 메모리의 범위를 넘치게 해서 원래의 리턴 주소를 변경시켜 임의의 프로그램이나 함수를 실행시키는 시스템 공격 기법
